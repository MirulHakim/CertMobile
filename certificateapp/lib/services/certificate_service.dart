import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'dart:io';
import '../models/certificate.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:pdf/pdf.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as path;
import 'package:file_picker/file_picker.dart';
import 'database_helper.dart';

class CertificateService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseStorage _storage = FirebaseStorage.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final DatabaseHelper _databaseHelper = DatabaseHelper();

  // Collection reference
  CollectionReference<Map<String, dynamic>> get _certificatesCollection =>
      _firestore.collection('certificates');

  // Get current user
  User? get currentUser => _auth.currentUser;

  // Create a new certificate (auto-generated or manual upload)
  Future<Certificate?> createCertificate({
    required String certName,
    required String issuer,
    required String recipientName,
    required String certificateType,
    required DateTime issueDate,
    DateTime? expiryDate,
    String? description,
    String? additionalInfo,
    File? certificateFile, // For manual PDF upload
    bool isAutoGenerated = true,
    String? signature,
    Map<String, dynamic>? metadata,
  }) async {
    try {
      final user = currentUser;
      if (user == null) throw Exception('User not authenticated');

      final certId = Certificate.generateCertId();
      final now = DateTime.now();
      String? fileUrl;
      String? fileName;
      double? fileSize;
      String? fileType;
      File? fileToUpload = certificateFile;

      // If auto-generated, create a PDF and upload it
      if (isAutoGenerated) {
        final pdfFile = await _generateCertificatePdf(
          certId: certId,
          certName: certName,
          issuer: issuer,
          recipientName: recipientName,
          certificateType: certificateType,
          issueDate: issueDate,
          expiryDate: expiryDate,
          description: description,
          additionalInfo: additionalInfo,
          signature: signature,
        );
        fileToUpload = pdfFile;
      }

      // Handle file upload if provided (manual upload or generated PDF)
      if (fileToUpload != null) {
        final uploadResult = await _uploadCertificateFile(fileToUpload, certId);
        fileUrl = uploadResult['url'];
        fileName = uploadResult['fileName'];
        fileSize = uploadResult['fileSize'];
        fileType = uploadResult['fileType'];
      }

      // Create certificate object
      final certificate = Certificate(
        certId: certId,
        certName: certName,
        issuer: issuer,
        recipientName: recipientName,
        certificateType: certificateType,
        issueDate: issueDate,
        expiryDate: expiryDate,
        description: description,
        additionalInfo: additionalInfo,
        fileUrl: fileUrl,
        fileName: fileName,
        fileSize: fileSize,
        fileType: fileType,
        isAutoGenerated: isAutoGenerated,
        createdBy: user.uid,
        createdByEmail: user.email ?? '',
        createdAt: now,
        updatedAt: now,
        status: 'active',
        signature: signature,
        metadata: metadata,
      );

      // Save to Firestore
      final docRef = await _certificatesCollection.add(certificate.toMap());

      // Return certificate with document ID
      return certificate.copyWith(id: docRef.id);
    } catch (e) {
      print('Error creating certificate: $e');
      rethrow;
    }
  }

  // Generate a PDF for the certificate
  Future<File> _generateCertificatePdf({
    required String certId,
    required String certName,
    required String issuer,
    required String recipientName,
    required String certificateType,
    required DateTime issueDate,
    DateTime? expiryDate,
    String? description,
    String? additionalInfo,
    String? signature,
  }) async {
    final pdf = pw.Document();
    pdf.addPage(
      pw.Page(
        pageFormat: PdfPageFormat.a4,
        build: (pw.Context context) {
          return pw.Container(
            padding: const pw.EdgeInsets.all(32),
            child: pw.Column(
              crossAxisAlignment: pw.CrossAxisAlignment.center,
              children: [
                pw.Text('Certificate of Achievement',
                    style: pw.TextStyle(
                        fontSize: 28, fontWeight: pw.FontWeight.bold)),
                pw.SizedBox(height: 24),
                pw.Text('Certificate ID: $certId',
                    style: pw.TextStyle(fontSize: 12, color: PdfColors.grey)),
                pw.SizedBox(height: 24),
                pw.Text(certName,
                    style: pw.TextStyle(
                        fontSize: 22, fontWeight: pw.FontWeight.bold)),
                pw.SizedBox(height: 16),
                pw.Text('Awarded to', style: pw.TextStyle(fontSize: 16)),
                pw.SizedBox(height: 8),
                pw.Text(recipientName,
                    style: pw.TextStyle(
                        fontSize: 20,
                        fontWeight: pw.FontWeight.bold,
                        color: PdfColors.blue)),
                pw.SizedBox(height: 16),
                pw.Text('Issued by: $issuer',
                    style: pw.TextStyle(fontSize: 16)),
                pw.SizedBox(height: 8),
                pw.Text('Type: $certificateType',
                    style: pw.TextStyle(fontSize: 16)),
                pw.SizedBox(height: 8),
                pw.Text(
                    'Issue Date: ${issueDate.day}/${issueDate.month}/${issueDate.year}',
                    style: pw.TextStyle(fontSize: 16)),
                if (expiryDate != null)
                  pw.Text(
                      'Expiry Date: ${expiryDate.day}/${expiryDate.month}/${expiryDate.year}',
                      style: pw.TextStyle(fontSize: 16)),
                if (description != null && description.isNotEmpty) ...[
                  pw.SizedBox(height: 16),
                  pw.Text('Description:',
                      style: pw.TextStyle(
                          fontSize: 14, fontWeight: pw.FontWeight.bold)),
                  pw.Text(description, style: pw.TextStyle(fontSize: 14)),
                ],
                if (additionalInfo != null && additionalInfo.isNotEmpty) ...[
                  pw.SizedBox(height: 16),
                  pw.Text('Additional Info:',
                      style: pw.TextStyle(
                          fontSize: 14, fontWeight: pw.FontWeight.bold)),
                  pw.Text(additionalInfo, style: pw.TextStyle(fontSize: 14)),
                ],
                if (signature != null && signature.isNotEmpty) ...[
                  pw.SizedBox(height: 32),
                  pw.Text('Signature:',
                      style: pw.TextStyle(
                          fontSize: 14, fontWeight: pw.FontWeight.bold)),
                  pw.Text(signature, style: pw.TextStyle(fontSize: 14)),
                ],
                pw.Spacer(),
                pw.Divider(),
                pw.Text('Generated by CertiSafe',
                    style: pw.TextStyle(fontSize: 10, color: PdfColors.grey)),
              ],
            ),
          );
        },
      ),
    );
    final output = await getTemporaryDirectory();
    final file = File('${output.path}/$certId.pdf');
    await file.writeAsBytes(await pdf.save());
    return file;
  }

  // Upload certificate file to Firebase Storage
  Future<Map<String, dynamic>> _uploadCertificateFile(
      File file, String certId) async {
    try {
      print('Uploading file: \\${file.path}');
      print('File exists: \\${file.existsSync()}');
      if (!file.existsSync()) {
        throw Exception('Selected file does not exist.');
      }
      final fileName = file.path.split('/').last;
      final fileExtension = fileName.split('.').last.toLowerCase();

      // Validate file type
      if (!['pdf', 'jpg', 'jpeg', 'png', 'doc', 'docx']
          .contains(fileExtension)) {
        throw Exception(
            'Invalid file type. Only PDF, JPG, PNG, DOC, DOCX are allowed.');
      }

      final storageRef = _storage.ref().child('certificates/$certId/$fileName');
      final uploadTask = storageRef.putFile(file);
      final snapshot = await uploadTask;
      final downloadUrl = await snapshot.ref.getDownloadURL();

      // Get file size synchronously
      final fileSize = await file.length();

      return {
        'url': downloadUrl,
        'fileName': fileName,
        'fileSize': fileSize.toDouble(),
        'fileType': fileExtension,
      };
    } catch (e) {
      print('Error uploading certificate file: \\${e}');
      rethrow;
    }
  }

  // Get all certificates
  Future<List<Certificate>> getAllCertificates() async {
    try {
      final querySnapshot = await _certificatesCollection
          .orderBy('createdAt', descending: true)
          .get();

      return querySnapshot.docs
          .map((doc) => Certificate.fromMap(doc.data(), id: doc.id))
          .toList();
    } catch (e) {
      print('Error getting certificates: $e');
      return [];
    }
  }

  // Get certificates by creator
  Future<List<Certificate>> getCertificatesByCreator(String creatorId) async {
    try {
      final querySnapshot = await _certificatesCollection
          .where('createdBy', isEqualTo: creatorId)
          .orderBy('createdAt', descending: true)
          .get();

      return querySnapshot.docs
          .map((doc) => Certificate.fromMap(doc.data(), id: doc.id))
          .toList();
    } catch (e) {
      print('Error getting certificates by creator: $e');
      return [];
    }
  }

  // Get certificates by recipient
  Future<List<Certificate>> getCertificatesByRecipient(
      String recipientName) async {
    try {
      final querySnapshot = await _certificatesCollection
          .where('recipientName', isEqualTo: recipientName)
          .orderBy('createdAt', descending: true)
          .get();

      return querySnapshot.docs
          .map((doc) => Certificate.fromMap(doc.data(), id: doc.id))
          .toList();
    } catch (e) {
      print('Error getting certificates by recipient: $e');
      return [];
    }
  }

  // Get certificate by ID
  Future<Certificate?> getCertificateById(String certificateId) async {
    try {
      final docSnapshot =
          await _certificatesCollection.doc(certificateId).get();

      if (docSnapshot.exists) {
        return Certificate.fromMap(docSnapshot.data()!, id: docSnapshot.id);
      }
      return null;
    } catch (e) {
      print('Error getting certificate by ID: $e');
      return null;
    }
  }

  // Update certificate
  Future<bool> updateCertificate(Certificate certificate) async {
    try {
      if (certificate.id == null)
        throw Exception('Certificate ID is required for update');

      await _certificatesCollection.doc(certificate.id).update({
        ...certificate.toMap(),
        'updatedAt': Timestamp.fromDate(DateTime.now()),
      });

      return true;
    } catch (e) {
      print('Error updating certificate: $e');
      return false;
    }
  }

  // Delete certificate
  Future<bool> deleteCertificate(String certificateId) async {
    try {
      // Get certificate to check if it has a file to delete
      final certificate = await getCertificateById(certificateId);
      if (certificate != null && certificate.fileUrl != null) {
        // Delete file from Firebase Storage
        try {
          final storageRef = _storage.refFromURL(certificate.fileUrl!);
          await storageRef.delete();
        } catch (e) {
          print('Error deleting file from storage: $e');
          // Continue with document deletion even if file deletion fails
        }
      }

      // Delete document from Firestore
      await _certificatesCollection.doc(certificateId).delete();
      return true;
    } catch (e) {
      print('Error deleting certificate: $e');
      return false;
    }
  }

  // Search certificates
  Future<List<Certificate>> searchCertificates(String query) async {
    try {
      // Search by certificate name, recipient name, or issuer
      final querySnapshot = await _certificatesCollection
          .where('certName', isGreaterThanOrEqualTo: query)
          .where('certName', isLessThan: query + '\uf8ff')
          .get();

      final results = <Certificate>[];

      // Add results from certName search
      results.addAll(querySnapshot.docs
          .map((doc) => Certificate.fromMap(doc.data(), id: doc.id)));

      // Search by recipient name
      final recipientQuery = await _certificatesCollection
          .where('recipientName', isGreaterThanOrEqualTo: query)
          .where('recipientName', isLessThan: query + '\uf8ff')
          .get();

      results.addAll(recipientQuery.docs
          .map((doc) => Certificate.fromMap(doc.data(), id: doc.id)));

      // Search by issuer
      final issuerQuery = await _certificatesCollection
          .where('issuer', isGreaterThanOrEqualTo: query)
          .where('issuer', isLessThan: query + '\uf8ff')
          .get();

      results.addAll(issuerQuery.docs
          .map((doc) => Certificate.fromMap(doc.data(), id: doc.id)));

      // Remove duplicates and sort by creation date
      final uniqueResults = results.toSet().toList();
      uniqueResults.sort((a, b) => b.createdAt.compareTo(a.createdAt));

      return uniqueResults;
    } catch (e) {
      print('Error searching certificates: $e');
      return [];
    }
  }

  // Get certificates by type
  Future<List<Certificate>> getCertificatesByType(
      String certificateType) async {
    try {
      final querySnapshot = await _certificatesCollection
          .where('certificateType', isEqualTo: certificateType)
          .orderBy('createdAt', descending: true)
          .get();

      return querySnapshot.docs
          .map((doc) => Certificate.fromMap(doc.data(), id: doc.id))
          .toList();
    } catch (e) {
      print('Error getting certificates by type: $e');
      return [];
    }
  }

  // Get certificates by status
  Future<List<Certificate>> getCertificatesByStatus(String status) async {
    try {
      final querySnapshot = await _certificatesCollection
          .where('status', isEqualTo: status)
          .orderBy('createdAt', descending: true)
          .get();

      return querySnapshot.docs
          .map((doc) => Certificate.fromMap(doc.data(), id: doc.id))
          .toList();
    } catch (e) {
      print('Error getting certificates by status: $e');
      return [];
    }
  }

  // Update certificate status
  Future<bool> updateCertificateStatus(
      String certificateId, String status) async {
    try {
      await _certificatesCollection.doc(certificateId).update({
        'status': status,
        'updatedAt': Timestamp.fromDate(DateTime.now()),
      });
      return true;
    } catch (e) {
      print('Error updating certificate status: $e');
      return false;
    }
  }

  // Add signature to certificate
  Future<bool> addSignature(String certificateId, String signature) async {
    try {
      await _certificatesCollection.doc(certificateId).update({
        'signature': signature,
        'updatedAt': Timestamp.fromDate(DateTime.now()),
      });
      return true;
    } catch (e) {
      print('Error adding signature: $e');
      return false;
    }
  }

  // Get certificate statistics
  Future<Map<String, dynamic>> getCertificateStats() async {
    try {
      final querySnapshot = await _certificatesCollection.get();
      final certificates = querySnapshot.docs
          .map((doc) => Certificate.fromMap(doc.data(), id: doc.id))
          .toList();

      final total = certificates.length;
      final active = certificates.where((c) => c.status == 'active').length;
      final expired = certificates.where((c) => c.isExpired).length;
      final autoGenerated = certificates.where((c) => c.isAutoGenerated).length;
      final manualUpload = certificates.where((c) => !c.isAutoGenerated).length;

      return {
        'total': total,
        'active': active,
        'expired': expired,
        'autoGenerated': autoGenerated,
        'manualUpload': manualUpload,
      };
    } catch (e) {
      print('Error getting certificate stats: $e');
      return {
        'total': 0,
        'active': 0,
        'expired': 0,
        'autoGenerated': 0,
        'manualUpload': 0,
      };
    }
  }

  // Upload file and save download URL to Firestore
  Future<void> uploadAndSaveFile(File file, String certId) async {
    final fileName = file.path.split('/').last;
    final storageRef =
        FirebaseStorage.instance.ref().child('certificates/$certId/$fileName');

    // Upload the file
    final uploadTask = storageRef.putFile(file);
    final snapshot = await uploadTask.whenComplete(() => {});

    // Get the download URL
    final downloadUrl = await snapshot.ref.getDownloadURL();

    // Save to Firestore
    await FirebaseFirestore.instance.collection('certificates').add({
      'fileUrl': downloadUrl,
      'fileName': fileName,
      'uploadedAt': Timestamp.now(),
      // ...add other fields as needed...
    });
  }

  Future<String?> uploadFileToFirebase(File file, String fileName) async {
    try {
      final storageRef =
          FirebaseStorage.instance.ref().child('certificates/$fileName');
      final uploadTask = await storageRef.putFile(file);
      final downloadUrl = await uploadTask.ref.getDownloadURL();
      return downloadUrl;
    } catch (e) {
      return null;
    }
  }

  // Add certificate (legacy method for file upload)
  Future<Certificate?> addCertificate() async {
    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: ['pdf', 'jpg', 'jpeg', 'png', 'doc', 'docx'],
        allowMultiple: false,
      );

      if (result != null) {
        final file = File(result.files.single.path!);
        final fileName = result.files.single.name;
        final fileSize = await file.length();
        final fileExtension = path.extension(fileName).toLowerCase();

        // Determine file type
        String fileType;
        switch (fileExtension) {
          case '.pdf':
            fileType = 'PDF';
            break;
          case '.jpg':
          case '.jpeg':
          case '.png':
            fileType = 'Image';
            break;
          case '.doc':
          case '.docx':
            fileType = 'Document';
            break;
          default:
            fileType = 'Other';
        }

        // Copy file to app directory
        final certDir = await _getCertificateDirectory();
        final uniqueFileName =
            '${DateTime.now().millisecondsSinceEpoch}_$fileName';
        final newFilePath = path.join(certDir, uniqueFileName);
        await file.copy(newFilePath);

        // Create certificate record
        final certificate = Certificate(
          certId: Certificate.generateCertId(),
          certName: fileName,
          issuer: 'Uploaded',
          recipientName: 'Unknown',
          certificateType: fileType,
          issueDate: DateTime.now(),
          description:
              'Certificate uploaded on ${DateTime.now().toString().split(' ')[0]}',
          fileUrl: newFilePath,
          fileName: fileName,
          fileSize: fileSize.toDouble(),
          fileType: fileType,
          isAutoGenerated: false,
          createdBy: currentUser?.uid ?? '',
          createdByEmail: currentUser?.email ?? '',
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
          status: 'active',
        );

        // Save to database
        final docRef = await _certificatesCollection.add(certificate.toMap());
        return certificate.copyWith(id: docRef.id);
      }
      return null;
    } catch (e) {
      print('Error adding certificate: $e');
      return null;
    }
  }

  // Get certificate directory
  Future<String> _getCertificateDirectory() async {
    final appDir = await getApplicationDocumentsDirectory();
    final certDir = Directory('${appDir.path}/certificates');
    if (!await certDir.exists()) {
      await certDir.create(recursive: true);
    }
    return certDir.path;
  }
}
